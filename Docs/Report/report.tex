\documentclass[hidelinks,12pt]{article}

\usepackage[italian]{babel}
\usepackage[a4paper]{geometry}
\usepackage{amsmath, tikz, hyperref, caption, subcaption}
\usepackage[capitalize, italian]{cleveref}
\usepackage[
   backend=biber,
   style=numeric,
 ]{biblatex}
\addbibresource{bib/db.bib}

% -- Font settings
\usepackage[math-style=ISO]{unicode-math}
\setmainfont{EB Garamond}%You should have installed the font
\setmathfont{Garamond-Math.otf}[StylisticSet={8,9}]
\setmathfont{Garamond-Math.otf}[range={scr,bfscr}]

\setlength{\parskip}{1.2ex}
\setlength{\parindent}{0em}
\clubpenalty = 100
\widowpenalty = 100

\title{STM32 GameBoy}
\date{\today}
\author{Marco Cutecchia, Edoardo Marangoni \\
\footnotesize \texttt{\{marco.cutecchia, edoardo.marangoni1\}@studenti.unimi.it} \\ }

\begin{document}
\maketitle

\section{Introduzione}
Il GameBoy è una console portatile rilasciata da Nintendo all'inizio degli anni
90 che diede inizio al grandissimo successo dei videogiochi tascabili.
La console vendette più di 118 milioni di unità nel mondo e divenne un fenomeno
culturale ricordato ancora oggi.

Lo scopo del progetto è quello di costruire un'imitazione del GameBoy in grado
di giocare tutti i videogiochi originali, ma con una serie di miglioramenti
grazie ai componenti hardware più moderni. Tra le modifiche al dispositivo
originale che abbiamo implementato troviamo il caricamento dei giochi tramite
microSD, invece che con cartucce, e l'utilizzo di uno schermo a colori e
retroilluminato, al contrario dell'originale schermo a scala di grigi che
diventava impossibile da vedere sotto scarsa luce.

\section{Hardware}
Le componenti hardware utilizzate sono tre: una scheda basata sul
SoC \texttt{STM32F411CEU6} (\cref{fig:weact_blackpill}),
uno schermo TFT da $2.4"$ utilizzante il controllore \texttt{ILI9341}
(\cref{fig:ili9341}) ed infine una PCB per la plancia di gioco clone
dell'originale utilizzata nel GameBoy (\cref{fig:pcb}).
Non è stato necessario comprare un lettore di schede microSD perchè il
display scelto ne integra uno al suo interno.

Oltre a questi componenti attivi sono stati utilizzati un interruttore SPDT,
dei pulsanti in plastica ed i rispettivi gommini da posizionare sopra la PCB
dei tasti, delle millefori (insieme a stagno, cavi e pin) per costruire i
collegamenti in modo da minimizzare lo spazio utilizzato ed infine un case di
GameBoy dove è stato alloggiato il tutto.

%\subsection{Microcontrollore}
La componente centrale del progetto è il microcontrollore
\texttt{STM32F411CEU6}, prodotto da ST e montato sulla board \texttt{WeAct Black
	Pill V2.0}. Il microcontrollore monta un core \texttt{ARM} Cortex-M4 con clock
massimo di $100$MHz (overclockato a $140$). Questo microcontrollore offre $34$
pin GPIO che verranno utilizzati per collegare il microcontrollore a schermo e
pad; monta $512$KiB di memoria flash e $128$KiB di SRAM, necessari per
l'esecuzione del software che abbiamo utilizzato.
\begin{figure}
	\begin{subfigure}[b]{0.45\textwidth}
		\begin{center}
			\begin{tikzpicture}[x=0.015cm, y=0.015cm, scale=0.5, transform shape]
				\input{figures/stm32.tex}
			\end{tikzpicture}
		\end{center}
		\caption{Pinout del microcontrollore STM32F411CEU6.}
		\label{fig:pinout_stm32}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\begin{center}
			\includegraphics[scale=0.5]{figures/stm32.jpg}
		\end{center}
		\caption{La scheda \texttt{WeAct Black Pill V2.0}.}
		\label{fig:weact_blackpill}
	\end{subfigure}
\end{figure}
%\subsection{Schermo}
Lo schermo che abbiamo utilizzato, basato sul controller \texttt{ILI9341}, è
uno schermo LCD da $2.4"$, con una risoluzione di $320x240$ e controllo
individuale dei pixel.
Una particolarità di questo schermo è che offre anche la possibilità di inserire
una scheda microSD al suo interno, che utilizziamo come memoria per i giochi.
\begin{figure}[h]
	\begin{subfigure}[b]{0.45\textwidth}
		\begin{center}
			\begin{tikzpicture}[x=0.015cm, y=0.015cm, scale=0.5, transform shape]
				\input{figures/ili.tex}
			\end{tikzpicture}
		\end{center}
		\caption{Pinout dello schermo \texttt{ILI9341}.}
		\label{fig:pinout_ili}

	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\begin{center}
			\includegraphics[scale=0.4]{figures/ili.png}
		\end{center}
		\caption{Lo schermo ILI9341.}
		\label{fig:ili9341}
	\end{subfigure}
\end{figure}

%\subsection{Gamepad}
L'ultimo componente hardware necessario è la plancia di gioco: per questo
utilizziamo una board costruita appositamente per il form factor del GameBoy
originale con $12$ tasti. Ne abbiamo utilizzati solo $8$: frecce direzionali,
\texttt{A}, \texttt{B}, \texttt{SELECT} e \texttt{START}.

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.4]{figures/pcb.jpeg}
	\end{center}
	\caption{La PCB GB DMG.}
	\label{fig:pcb}
\end{figure}


\section{Architettura}

\section{Software}
Il software necessario per il progetto si divide nei seguenti moduli: gestione
della scheda microSD, emulatore, interfaccia con lo schermo e una GUI per la
selezione dei giochi.

\subsection{Emulatore}
L'emulatore che abbiamo scelto è scritto in C (originariamente per desktop),
chiamato \texttt{peanutGB}. Questo emulatore è distribuito utilizzando un
singolo header C contenente tutte le funzioni per l'emulazione di un GB,
disponendo per l'utente le funzionalità base per l'esecuzione delle ROM del GB
comprese di audio e gestione dei comandi: sarà compito dell'utente implementare
degli \textit{hooks} (\texttt{gb\_rom\_read}, \texttt{gb\_cart\_ram\_read},
\texttt{gb\_cart\_ram\_write}, \texttt{gb\_error}) per fornire all'emulatore
l'interfaccia con la  ROM del gioco da giocare e la gestione degli errori. Il
porting di questo emulatore per il microcontrollore non ha richiesto particolari
modifiche.

\subsubsection{Colori}
Originariamente, il GB disegnava esclusivamente in \textit{grayscale}: ogni
oggetto (sfondo, dialoghi, sprites, transizioni...) è assegnato ad uno dei $4$
\textit{layer} che il GB offre, che viene ulteriormente diviso in $4$
\textit{variables}, come mostrato in \cref{table:gb_colors}.
Con il rilascio del \textit{Game Boy Color}, \textit{Nintendo} preparò una serie
di \textit{palette} di colori per permettere ai giochi rilasciati in bianco e nero
di diventare a colori. Queste palette sono semplicemente 4 colori in formato BGR565
per ognuno dei 4 layer supportati.

Abbiamo estratto alcune palette dei giochi più popolari ed implementato questo
meccanismo di conversione dei colori grayscale nel corrispondente colore della
palette del layer del momento.

\begin{table}[h]
	\begin{tabular}{|l|l|llll|}
		\hline
		\textbf{Layer} & \textbf{Descrizione di uso tipico}                    & \multicolumn{4}{l|}{\textbf{Variabili}}                                                          \\ \hline
		\textbf{BG0}   & Sfondo                                                & \multicolumn{1}{l|}{B1}                 & \multicolumn{1}{l|}{B2} & \multicolumn{1}{l|}{B3} & B4 \\ \hline
		\textbf{Win}   & Menu a finestra: stato, pausa, mappa, inventario, HUD & \multicolumn{1}{l|}{W1}                 & \multicolumn{1}{l|}{W2} & \multicolumn{1}{l|}{W3} & W4 \\ \hline
		\textbf{Obj0}  & Sprites principali                                    & \multicolumn{1}{l|}{–}                  & \multicolumn{1}{l|}{S2} & \multicolumn{1}{l|}{S3} & S4 \\ \hline
		\textbf{Obj1}  & Transizioni, sprites secondari                        & \multicolumn{1}{l|}{–}                  & \multicolumn{1}{l|}{P2} & \multicolumn{1}{l|}{P3} & P4 \\ \hline
	\end{tabular}
	\caption{Tabella dei colori per il GB (da
		\cite{GameBoyColors}).}
	\label{table:gb_colors}
\end{table}

\subsection{Scheda SD}
Fisicamente, la scheda microSD è inserita nello schermo ILI9341, che dispone di
un'apposita porta; per interfacciarci con essa, abbiamo deciso di formattare la
scheda con un filesystem FAT e utilizzare, come descritto in \cite{stm1721}, una
libreria per l'interazione con tali filesystem astratta dal livello di fisico di
I/O; abbiamo pertanto utilizzato un'ulteriore libreria per interfacciarci con
la scheda SD: questo meccanismo viene implementato utilizzando i pin esposti
dallo schermo e direttamente collegati alla microSD (\texttt{SD\_SCK},
\texttt{SD\_DO}, \texttt{SD\_DI}, \texttt{SD\_SS}) che permettono l'utilizzo
dell'interfaccia seriale della scheda.

\subsubsection{Caching dei settori}
Abbiamo osservato che durante l'esecuzione la lettura dei blocchi della SD
costituiva un collo di bottiglia per la performance, tanto da rendere
impossibile l'utilizzo della console. Sfortunatamente la grande maggioranza
dei giochi sono troppo grandi per essere caricati interamente in memoria RAM,
con alcuni giochi che addirittura arrivano a MB di dimensione.

Per mitigare questo problema abbiamo implementato un meccanismo di caching dei
dati letti dalla SD con una strategia "Least Recently Used".
Durante l'inizializzazione dell'emulatore viene creata in memoria una struct
\texttt{Cache} contenente una linked list in cui vengono salvati i contenuti
dei blocchi letti dalla della SD.
In questa struct vengono mantenuti anche i metadati necessari per
ritrovare il blocco utilizzato più recentemente e meno recentemente; questi dati
e la lista vengono aggiornati in base alle richieste, inserendo il blocco
richiesto più recentemente in cima alla lista e contestualmente rimuovere quello
richiesto meno recentemente.

Tramite misurazioni empiriche abbiamo ottenuto le performance migliori
utilizzando una dimensione dei blocchi di $512$ bytes, riservando $20$KB di
memoria RAM per la cache (dunque fino a $40$ blocchi caricati temporanemente).
Questo meccanismo di caching è un modulo fondamentale; senza di esso l'esecuzione
dei giochi diventa talmente lenta al punto da essere inaccettabile.

%\subsubsection{Scrittura dei salvataggi}
%Durante l'esecuzione dei giochi, gli utenti possono salvare i propri progressi
%in dei file appositi gestiti dall'emulatore. Invece di rallentare l'esecuzione ad
%ogni salvataggio,  abbiamo deciso di utilizzare una coda per scrivere i
%salvataggi in blocco. 

\subsection{Driver ILI9341}
Per interfacciarsi con lo schermo è stato necessario scrivere un driver
apposito: per questa componente in particolare abbiamo speso buona parte del
tempo necessario per il completamento del progetto. Lo schermo \texttt{ILI9341}
dispone per l'utilizzatore $5$ pin di controllo: \texttt{LCD\_RD},
\texttt{LCD\_WR}, \texttt{LCD\_RS}, \texttt{LCD\_CS}, ed \texttt{LCD\_RST}.
Questi pin vengono utilizzati per modificare lo stato della scheda, come
descritto nella documentazione ufficiale.
\begin{table}[h]
	\begin{verbatim}

  int ILI9341_Init(struct ILI9341_t *ili, struct ILI9341_Pin_t D7,
                 struct ILI9341_Pin_t D6, struct ILI9341_Pin_t D5,
                 struct ILI9341_Pin_t D4, struct ILI9341_Pin_t D3,
                 struct ILI9341_Pin_t D2, struct ILI9341_Pin_t D1,
                 struct ILI9341_Pin_t D0, struct ILI9341_Pin_t RST,
                 struct ILI9341_Pin_t CS, struct ILI9341_Pin_t RS,
                 struct ILI9341_Pin_t WR, struct ILI9341_Pin_t RD);

  [...]

  void ILI9341_DrawFramebufferScaled(struct ILI9341_t *ili, 
                 uint16_t framebuffer[]);
  \end{verbatim}
	\caption{}
	\label{table:driver_ili}
\end{table}
\subsubsection{Ad alto livello}
Nella \cref{table:driver_ili} mostriamo parte delle funzioni che, ad alto
livello, il driver implementa: ovviamente, \texttt{ILI9341\_Init} è utilizzata
per inizializzare l'unità; \texttt{ILI9341\_DrawFramebufferScaled}, anch'essa
abbastanza auto-esplicativa, è tra le funzioni del driver più utilizzate dal
codice utente per disegnare sullo schermo. Originariamente il GB mostrava uno
schermo $160\times144$: tra le migliorie che abbiamo implementate vi è anche lo
scaling dell'immagine dello schermo, che è aumentata a $320\times240$.
Esaminiamo ora l'implementazione di queste due funzioni. Una struct mantiene lo
stato interno dei collegamenti tra microcontrollore e scheda, e tramite le
procedure offerte dal meccanismo GPIO di \texttt{HAL} possiamo impostare lo
stato dei pin dello schermo.

\subsubsection{Inizializzazione}
La funzione di inizializzazione è parametrizzata dagli identificatori dei pin
GPIO del microcontrollore che vengono collegati ai pin della scheda: una volta
inizializzata la struct che mantiene le corrispondenze di questi collegamenti,
si procede ad inizializzare i pin di controllo della scheda ( \texttt{LCD\_RD},
\texttt{LCD\_WR}, \texttt{LCD\_RS}, \texttt{LCD\_CS}, ed \texttt{LCD\_RST}) come
pin di output tramite le funzioni messe a disposizione da HAL. Diamo quindi uno
stato iniziale alla scheda prima di procedere alla sequenza di inizializzazione:
il pin \texttt{LCD\_CS} è impostato come \textit{attivo} (quindi \textit{low},
come da richieste della scheda). Questo significa che la scheda è pronta a
ricevere dei comandi inviati dal microcontrollore. Si imposta quindi come
disabilitato (ossia \textit{high}) il pin \texttt{LCD\_RST}: questo pin forza la
scheda ad eseguire il reset, pertanto durante tutta l'esecuzione (o finché non
si desidera resettare lo schermo) dovrà rimanere disabilitato.
Si impostano disablitati i pin \texttt{LCD\_WR} e \texttt{LCD\_RD}; infine si
imposta come attivo (quindi \textit{low}) il pin \texttt{LCD\_CD}, che sta a
significare che la scheda riceverà sui pin dati un comando.

L'effettiva sequenza di inizializzazione della scheda comporta l'attivazione del
pin \texttt{LCD\_RST} seguito da un delay  e la seguente disattivazione dello
stesso pin seguito da un ulteriore delay.

\subsubsection{Disegnare sullo schermo}
La funzione \texttt{ILI9341\_DrawFramebufferScaled} utilizza l'interfaccia della
scheda e il protocollo descritto nella documentazione per disegnare sullo
schermo. Nella nostra implementazione abbiamo scelto di utilizzare un framebuffer
globale sul quale emulatore e GUI disegnano.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.8]{figures/wr_cycle.png}
	\caption{}
	\label{fig:ili_wr_cycle}
\end{figure}

Per implementare il protocollo, la funzione imposta lo schermo per
la ricezione di comandi e invia inizialmente una \texttt{nop}, con lo scopo di
sincronizzare scheda e microcontrollore.

Il protocollo della scheda prevede che il client, per disegnare sullo schermo,
imposti inizialmente l'area sulla quale vuole disegnare.
L'utente dispone dei comandi \texttt{COLUMN\_ADDRESS\_SET} e
\texttt{PAGE\_ADDRESS\_SET}: il primo comando è utilizzato per specificare le
due colonne destra e sinistra che delimitano l'area in cui si vuole disegnare, e
simmetricamente fa il secondo comando; entrambi i comandi richiedono quattro
parametri da $8$bit che indicano i $2+2$ byte necessari per identificare righe e
colonne. Una volta specificata l'area, l'utente utilizzerà il comando
\texttt{MEMORY\_WRITE} per inviare alla scheda i dati che descrivono il disegno:
ogni pixel dello schermo è descritto da due byte in formato BGR565.

Nell'implementazione abbiamo deciso di forzare l'utilizzo dei pin
\texttt{A0}-\texttt{A7} del microcontrollore per l'invio dei dati allo schermo
(ossia devono essere collegati ai pin \texttt{D0}-\texttt{D7} dello schermo): in
questo modo possiamo scrivere direttamente sul registro \texttt{GPIOA->ODR} il
byte da inviare. Possiamo dunque evitare l'utilizzo della HAL di ST e di
operazioni di \texttt{mask} e \texttt{shift}: questo ci permette di ottenere
prestazioni migliori evitando overhead non indifferenti.

\paragraph{Scaling}
L'algoritmo di scaling che abbiamo implementato cerca di scalare l'immagine
prodotta da GUI ed emulatore senza sacrificare le performance, ed è pertanto
relativamente semplice: aggiungiamo un pixel ogni due, sia in verticale che in
orizzontale; il nuovo pixel avrà come colore la media dei colori dei due pixel
che lo hanno generato.

\subsection{GUI}
\begin{figure}[h]
	\begin{center}
		\begin{subfigure}[b]{0.4\textwidth}
			\begin{center}
				\includegraphics[scale=0.65]{figures/game_choice_gui.png}
			\end{center}
			\caption{}
			\label{fig:gui_choice}
		\end{subfigure}
		\hfill
		\begin{subfigure}[b]{0.4\textwidth}
			\begin{center}
				\includegraphics[scale=0.2]{figures/error_gui.png}
			\end{center}
			\caption{}
			\label{fig:gui_err}
		\end{subfigure}
	\end{center}
	\caption{}
\end{figure}
Abbiamo scritto una semplice GUI per permettere all'utente di scegliere i giochi
disponibili sulla scheda SD (\cref{fig:gui_choice}) o, in caso non vi siano
giochi disponibili sulla scheda SD (o non sia inserita) mostrare a schermo un
messaggio di errore (\cref{fig:gui_err}).
In rete sono disponibili diversi framework per sviluppare GUI su ambienti
embedded, abbiamo però deciso di non utilizzarli ed invece di implementare
da zero tutto data la relativa semplicità dell'interfaccia che abbiamo immaginato.

\subsubsection{Font PSF}
Questo componente software scrivere direttamente i valori dei pixel nel
framebuffer globale. Per poter mostrare a video i nomi dei giochi disponibili è
necessario implementare la risoluzione di font sullo schermo: per fare questo
abbiamo utilizzato i font PSF che codificano ogni \textit{glifo} (ossia ogni
simbolo, ad esempio una lettera) come bitmap. Nel font che abbiamo scelto, i
simboli vengono codificati come $8$ righe di $8$ bit ciascuna: un bit $i = 0$
indica che per mostrare il glifo, il pixel corrispondente al bit $i$ deve avere
il colore di background dello schermo, mentre un bit $i = 1$ indica che il pixel
deve avere il colore di foreground. Assieme con queste bitmap, per implementare
la GUI sono bastate delle funzioni che svolgono dei  semplici calcoli sulle
dimensione del framebuffer (ossia calcolare i rettangoli in cui andare a
dipingere i glifi). 
\begin{table}[h]
  \begin{verbatim}
// Character 48
Bitmap: -#####-- \
        ##---##- \
        ##--###- \
        ##-#-##- \
        ###--##- \
        ##---##- \
        -#####-- \
        --------
Unicode: [00000030];
  \end{verbatim}
  \caption{Il glifo ``0'' nel font PSF \texttt{koi8r} per l'alfabeto cirillico.}
\end{table}

\section{Assemblaggio}
Abbiamo speso una buona parte del tempo totale della realizzazione del progetto
a pianificare e tentare vari approcci per l'assemblaggio finale. Questa parte di
svolgimento, infatti, si è rivelata più ostica del previsto, poiché l'insieme
dei componenti e dei cavi non stava nel case del GB.

Essendo la PCB del gamepad un clone dell'originale del GameBoy, il case è
costruito per alloggiarla comodamente. Sfortunatamente non si può dire lo
stesso del nostro schermo e microcontrollore, essendo componenti completamente
diversi da quelli trovati nel GB.
Nel GB originale l'intera circuiteria è posizionata dietro lo schermo; in
questo spazio il nostro display e microcontrollore occupano l'intero spazio
verticale, lasciando veramente poco spazio per i cavi.
Il nostro primo tentativo di utilizzare dei semplici cavetti per i collegamenti
si è rivelato fallimentare: l'alto numero di collegamenti e il loro spessore
(anche dopo averli accorciati) rendevano difficilissimo chiudere il case.
Inoltre, anche dopo essere riusciti a chiudere il tutto, questi cavetti erano
proni a staccarsi dai pin durante la sessione di gioco.

La soluzione è stata quella di riprodurre i collegamenti su una millefori,
saldando dei cavetti piatti in stagno su di essa ed utilizzando dei pin header
femmina che fungono da alloggiamento per il microcontrollore.
Questa millefori, tagliata per essere delle stesse dimensioni dello schermo, è
stata progettata per essere saldata sui pin dello schermo, riducendo al minimo
lo spessore totale.

[Side by side: Immagine Millefori Davanti, Immagine Millefori di Lato]

Questa millefori espone dei pin maschio per l'alimentazione (5V e GND)
e per i tasti (da PB0 a PB8), collegati direttamente ai pin del
microcontrollore.
Questi pin vengono collegati rispettivamente al cavi dell'alimentazione e
ai pin della PCB dei tasti. 

\subsection{Alimentazione}
La scheda che abbiamo scelto contiene al suo interno un regolatore di tensione
in input da $+3.52$V fino $+5.25$V, questo ci ha permesso di costruire un
sistema di alimentazione molto semplice, composto banalmente da 3 batteria AA
($1.5$V ciascuna) in serie per un totale di $+4.5$V in ingresso.

In mezzo ai cavi che collegano batterie e microcontrollore troviamo un semplice
interruttore, che viene posizionato sulla parte superiore del GameBoy.
L'interruttore utilizzato è un switch SPDT, dunque a singolo polo con doppia
mandata, ma noi utilizziamo solamente una delle due mandate.
La scelta di utilizzare uno switch a due mandate invece di uno con singola
mandata è semplicemente perchè i primi sono molto più economici e reperibili
dei secondi.
Lo switch ed i cavi a cui è collegato sono stato saldati su un piccolo pezzo
di millefori, tagliato per fare in modo che si incastri nelle incavature già
presenti nel case del GameBoy.



\addcontentsline{toc}{section}{References}
\nocite{*}
\printbibliography
\end{document}
